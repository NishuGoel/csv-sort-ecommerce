"use strict";

var _fs = _interopRequireDefault(require("fs"));

var _npmlog = _interopRequireDefault(require("npmlog"));

var _prettyError = _interopRequireDefault(require("pretty-error"));

var _yargs = _interopRequireDefault(require("yargs"));

var _constants = _interopRequireDefault(require("./constants"));

var _lineItemState = _interopRequireDefault(require("./parsers/line-item-state"));

var _addReturnInfo = _interopRequireDefault(require("./parsers/add-return-info"));

var _deliveries = _interopRequireDefault(require("./parsers/deliveries"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

process.title = 'csvparserorder';

const args = _yargs.default.usage(`\n
Usage: $0 [options]
Convert commercetools order CSV data to JSON.`).showHelpOnFail(false).option('type', {
  alias: 't',
  choices: ['lineitemstate', 'returninfo', 'deliveries'],
  describe: 'Predefined type of csv.',
  demand: true
}).option('inputFile', {
  alias: 'i',
  default: 'stdin',
  describe: 'Path to input CSV file.'
}).coerce('inputFile', arg => {
  if (arg !== 'stdin') return _fs.default.createReadStream(String(arg));
  return process.stdin;
}).option('outputFile', {
  alias: 'o',
  default: 'stdout',
  describe: 'Path to output JSON file.'
}).coerce('outputFile', arg => {
  if (arg !== 'stdout') return _fs.default.createWriteStream(String(arg));
  return process.stdout;
}).option('batchSize', {
  alias: 'b',
  default: _constants.default.standardOption.batchSize,
  describe: 'Number of CSV rows to handle simultaneously.'
}).option('delimiter', {
  alias: 'd',
  default: _constants.default.standardOption.delimiter,
  describe: 'Used CSV delimiter.'
}).option('encoding', {
  alias: 'e',
  default: _constants.default.standardOption.encoding,
  describe: 'Used CSV encoding.'
}).option('strictMode', {
  alias: 's',
  default: _constants.default.standardOption.strictMode,
  describe: 'Parse CSV strictly.'
}).option('logLevel', {
  alias: 'l',
  default: _constants.default.standardOption.defaultLogLevel,
  describe: 'Logging level: error, warn, info or verbose.'
}).option('logFile', {
  default: _constants.default.standardOption.defaultLogFile,
  describe: 'Path to file where to save logs.'
}).argv;

const logError = error => {
  const errorFormatter = new _prettyError.default();
  if (_npmlog.default.level === 'verbose') process.stderr.write(`ERR: ${errorFormatter.render(error)}`);else process.stderr.write(`ERR: ${error.message || error}`);
};

const errorHandler = errors => {
  if (Array.isArray(errors)) errors.forEach(logError);else logError(errors);
  process.exitCode = 1;
};

const getModuleConfig = () => ({
  logger: {
    error: _npmlog.default.error.bind(void 0, ''),
    warn: _npmlog.default.warn.bind(void 0, ''),
    info: _npmlog.default.info.bind(void 0, ''),
    verbose: _npmlog.default.verbose.bind(void 0, '')
  },
  csvConfig: {
    delimiter: args.delimiter,
    batchSize: args.batchSize,
    strictMode: args.strictMode
  }
});

if (args.outputFile === process.stdout) _npmlog.default.stream = _fs.default.createWriteStream(args.logFile);
const methodMapping = {
  lineitemstate: config => new _lineItemState.default(config),
  returninfo: config => new _addReturnInfo.default(config),
  deliveries: config => new _deliveries.default(config)
}; // Register error listener

args.outputFile.on('error', errorHandler);
args.inputFile.setEncoding(args.encoding);
methodMapping[args.type](getModuleConfig()).parse(args.inputFile, args.outputFile);